<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Button of Dictator</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Project stylesheet for this page -->
  <link rel="stylesheet" href="css/trigger.css" />

  <!-- Fonts aligned with the 404 background -->
  <link rel="stylesheet"
    href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@100;200;300;400;500;600;700&family=Orbitron:wght@400;500;600;700;800;900&family=Saira:wght@100;200;300;400;500;600;700;800;900&display=swap" />

  <link rel="icon" href="/images/favicon-terminate-flat.ico" sizes="any">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/terminate-flat-32.png">
  <link rel="icon" type="image/png" sizes="64x64" href="/images/terminate-flat-64.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/terminate-flat-180.png">
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>

<body>
  <section class="section-background">
    <div class="scrolling-wrapper">
      <div class="dark-frame">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" preserveAspectRatio="none"
          style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: #4d4d4d; pointer-events: none; z-index: 0;">
          <defs>
            <filter id="softEdge" x="-10%" y="-10%" width="120%" height="120%">
              <feGaussianBlur in="SourceGraphic" stdDeviation="3"></feGaussianBlur>
            </filter>
          </defs>
          <path d="
            M2,10
            C2,3 3,2 10,2
            L90,2
            C97,2 98,3 98,10
            L98,90
            C98,97 97,98 90,98
            L10,98
            C3,98 2,97 2,90
            Z" fill="#999999" filter="url(#softEdge)"></path>
        </svg>
      </div>

      <div class="scrolling-track">
        <!-- Repeated 404 text shells -->
        <div class="bg-text-shell">
          <div class="bg-clone-shell">
            <div class="bg-text-clone r">TRIGGER</div>
            <div class="bg-text-clone g">TRIGGER</div>
            <div class="bg-text-clone b">TRIGGER</div>
          </div>
          <div data-text="TERMINATED" class="bg-text">TRIGGER</div>
        </div>
        <div class="bg-text-shell">
          <div class="bg-clone-shell">
            <div class="bg-text-clone r">TRIGGER</div>
            <div class="bg-text-clone g">TRIGGER</div>
            <div class="bg-text-clone b">TRIGGER</div>
          </div>
          <div class="bg-text">TRIGGER</div>
        </div>
        <div class="bg-text-shell">
          <div class="bg-clone-shell">
            <div class="bg-text-clone r">TRIGGER</div>
            <div class="bg-text-clone g">TRIGGER</div>
            <div class="bg-text-clone b">TRIGGER</div>
          </div>
          <div class="bg-text">TRIGGER</div>
        </div>
        <div class="bg-text-shell">
          <div class="bg-clone-shell">
            <div class="bg-text-clone r">TRIGGER</div>
            <div class="bg-text-clone g">TRIGGER</div>
            <div class="bg-text-clone b">TRIGGER</div>
          </div>
          <div class="bg-text">TRIGGER</div>
        </div>
        <div class="bg-text-shell">
          <div class="bg-clone-shell">
            <div class="bg-text-clone r">TRIGGER</div>
            <div class="bg-text-clone g">TRIGGER</div>
            <div class="bg-text-clone b">TRIGGER</div>
          </div>
          <div class="bg-text">TRIGGER</div>
        </div>
        <div class="bg-text-shell">
          <div class="bg-clone-shell">
            <div class="bg-text-clone r">TRIGGER</div>
            <div class="bg-text-clone g">TRIGGER</div>
            <div class="bg-text-clone b">TRIGGER</div>
          </div>
          <div class="bg-text">TRIGGER</div>
        </div>
        <div class="bg-text-shell">
          <div class="bg-clone-shell">
            <div class="bg-text-clone r">TRIGGER</div>
            <div class="bg-text-clone g">TRIGGER</div>
            <div class="bg-text-clone b">TRIGGER</div>
          </div>
          <div class="bg-text">TRIGGER</div>
        </div>

        <script>
          (function () {
            const track = document.querySelector('.scrolling-track');
            if (!track) return;

            const shells = Array.from(track.querySelectorAll('.bg-text-shell'));
            const items = Array.from(track.querySelectorAll('.bg-text'));

            // 动画参数
            const speed = 0.5;                 // px/帧（你原先的速度）
            let step = 0;                    // 一次完整循环应位移的距离
            let pos = 0;                    // 当前 translateX 偏移（正值向左）
            let rafId = null;

            // 用户减少动画偏好
            const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

            // 等字体就绪，再测量（fallback 安全）
            async function waitForFonts() {
              if (document.fonts && document.fonts.ready) {
                try { await document.fonts.ready; } catch (e) { }
              }
              // 再等两帧，确保回流完成
              await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
            }

            // 计算循环步长：用相邻两个 shell 的 offsetLeft 之差
            function computeStep() {
              if (shells.length >= 2) {
                const a = shells[0].offsetLeft;
                const b = shells[1].offsetLeft;
                const d = b - a;
                if (d > 0) return d;
              }
              // 兜底：文字宽度 + 10vw（与旧逻辑一致）
              const itemWidth = items[0]?.offsetWidth || 0;
              const gap = window.innerWidth * 0.1;
              return itemWidth + gap;
            }

            function applyTransform() {
              // 用模运算平滑回环；注意是负方向平移
              const wrapped = ((pos % step) + step) % step;
              track.style.transform = `translateX(${-wrapped}px)`;
            }

            function tick() {
              pos += speed;
              applyTransform();
              rafId = requestAnimationFrame(tick);
            }

            // 重新测量（窗口变化/字体变化时）
            function remeasure() {
              const oldStep = step;
              step = computeStep();
              if (step <= 0) return;

              // 将当前位置按新步长重新包裹，避免跳变
              pos = ((pos % step) + step) % step;
              applyTransform();
            }

            // 初始化
            (async function init() {
              // 初始透明度淡入（保持你原来的效果）
              items.forEach(el => { el.style.opacity = '0'; el.style.transition = 'opacity 1s ease-out'; });

              await waitForFonts();
              step = computeStep();
              applyTransform();

              // 1s 后开始动画（沿用你的时序）
              setTimeout(() => {
                if (!prefersReduced) rafId = requestAnimationFrame(tick);
                items.forEach(el => { el.style.opacity = '1'; });
              }, 1000);

              // 监听 resize（含 DPR 变化）
              let resizeTimer = null;
              window.addEventListener('resize', () => {
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(remeasure, 50);
              });

              // 字体集合事件（部分浏览器支持）
              if (document.fonts && typeof document.fonts.addEventListener === 'function') {
                document.fonts.addEventListener('loadingdone', remeasure);
                document.fonts.addEventListener('loadingerror', remeasure);
              }
            })();
          })();
        </script>


        <style>
          .bg-text,
          .bg-text-clone {
            pointer-events: none;
            will-change: transform, opacity;
          }

          .bg-text-clone {
            opacity: 0;
            transition: transform 0.05s ease, opacity 0.1s ease;
            mix-blend-mode: screen;
            z-index: 0;
          }
        </style>

        <script>
          document.addEventListener("DOMContentLoaded", () => {
            const shells = document.querySelectorAll('.bg-text-shell');
            let isCrtRunning = false;
            let tinyGlitchTimer = null;
            let bigGlitchTimer = null;

            function clearClones() {
              shells.forEach(shell => {
                shell.querySelectorAll('.bg-text-clone').forEach(clone => {
                  clone.style.opacity = 0;
                  clone.style.transform = 'translate(0, 0) scale(1)';
                  clone.style.filter = 'none';
                });
              });
            }
            function doTinyGlitch() {
              if (isCrtRunning) return;
              shells.forEach(shell => {
                const clones = shell.querySelectorAll('.bg-text-clone');
                const offsetX = () => (Math.random() * 12 - 6) + "px";
                const offsetY = () => (Math.random() * 12 - 6) + "px";
                const randomOpacity = 0.15 + Math.random() * 0.1;
                clones.forEach(clone => {
                  clone.style.opacity = randomOpacity.toFixed(2);
                  clone.style.transform = `translate(${offsetX()}, ${offsetY()})`;
                  clone.style.filter = "none";
                });
                setTimeout(() => {
                  clones.forEach(clone => {
                    clone.style.opacity = 0;
                    clone.style.transform = `translate(0, 0)`;
                  });
                }, 200);
              });
            }
            function scheduleTinyGlitch() {
              if (tinyGlitchTimer) clearTimeout(tinyGlitchTimer);
              if (isCrtRunning) return;
              doTinyGlitch();
              tinyGlitchTimer = setTimeout(scheduleTinyGlitch, Math.random() * 1000 + 1000);
            }
            function doBigGlitchOnce() {
              shells.forEach(shell => {
                const clones = shell.querySelectorAll('.bg-text-clone');
                const offsetX = () => (Math.random() * 100 - 50) + "px";
                const offsetY = () => (Math.random() * 100 - 50) + "px";
                const randomOpacity = 0.7 + Math.random() * 0.25;
                clones.forEach(clone => {
                  clone.style.opacity = randomOpacity.toFixed(2);
                  clone.style.transform = `translate(${offsetX()}, ${offsetY()}) scale(${1 + Math.random() * 0.08})`;
                  clone.style.filter = "blur(0.6px) contrast(150%)";
                });
                setTimeout(() => {
                  clones.forEach(clone => {
                    clone.style.opacity = 0;
                    clone.style.transform = `translate(0, 0) scale(1)`;
                    clone.style.filter = "none";
                  });
                }, 180);
              });
            }
            function scheduleBigGlitch() {
              if (bigGlitchTimer) clearTimeout(bigGlitchTimer);
              if (isCrtRunning) return;
              const blastCount = Math.floor(Math.random() * 3) + 1;
              let delay = 0;
              for (let i = 0; i < blastCount; i++) {
                setTimeout(() => { if (!isCrtRunning) doBigGlitchOnce(); }, delay);
                delay += 160 + Math.random() * 40;
              }
              const nextDelay = delay + Math.random() * 3000 + 3000;
              bigGlitchTimer = setTimeout(scheduleBigGlitch, nextDelay);
            }
            function startGlitches() { scheduleTinyGlitch(); scheduleBigGlitch(); }
            function stopGlitches() {
              clearTimeout(tinyGlitchTimer); clearTimeout(bigGlitchTimer);
              tinyGlitchTimer = null; bigGlitchTimer = null; clearClones();
            }
            function crtEffect() {
              isCrtRunning = true; stopGlitches();
              shells.forEach(shell => {
                const texts = shell.querySelectorAll('.bg-text, .bg-text-clone');
                texts.forEach(text => {
                  text.style.transition = "none";
                  text.style.transform = "scaleY(1) scaleX(1) translate(0, 0)";
                  text.style.opacity = "1"; text.style.filter = "none";
                });
                setTimeout(() => {
                  texts.forEach(text => {
                    if (text.classList.contains('bg-text-clone')) {
                      text.style.transition = "opacity 0.2s ease-out, transform 0.2s ease-in";
                      text.style.opacity = "0"; text.style.transform = "scaleY(0.05) scaleX(1)";
                    } else {
                      text.style.transition = "transform 0.2s ease-in";
                      text.style.transform = "scaleY(0.05) scaleX(1)"; text.style.opacity = "1";
                    }
                  });
                }, 10);
                setTimeout(() => {
                  texts.forEach(text => {
                    text.style.transition = "transform 0.1s ease-in, opacity 0.1s ease-out";
                    text.style.transform = "scaleY(0.05) scaleX(0)"; text.style.opacity = "0";
                  });
                }, 210);
                setTimeout(() => {
                  texts.forEach(text => {
                    text.style.transition = "opacity 3s ease-out, transform 0s";
                    text.style.transform = "scaleY(1) scaleX(1)"; text.style.opacity = "1";
                  });
                  isCrtRunning = false; startGlitches();
                }, 1800);
              });
            }
            setTimeout(() => { crtEffect(); setInterval(crtEffect, 12000); }, 3000);
          });
        </script>
      </div>
    </div>

    <div class="glass-layer"></div>

    <div class="grain-overlay"></div>

    <script>
      (function () {
        const overlay = document.querySelector(".grain-overlay");
        if (!overlay) return;
        const style = document.createElement('style');
        style.textContent = `
          .grain-overlay { pointer-events: none; opacity: 0.15; }
          .grain-overlay canvas {
            width: 100%; height: 100%; display: block; position: absolute; top: 0; left: 0;
            image-rendering: pixelated;
          }`;
        document.head.appendChild(style);

        if (supportsWebGL()) { initWebGLGrain(); } else { initCanvas2DGrain(); }

        function supportsWebGL() { try { const c = document.createElement("canvas"); return !!window.WebGLRenderingContext && c.getContext("webgl"); } catch (e) { return false; } }

        function initWebGLGrain() {
          const layers = [
            { id: "grain-base", frag: baseFrag },
            { id: "grain-float", frag: floatFrag },
            { id: "grain-warp", frag: warpFrag }
          ];
          const dpr = window.devicePixelRatio || 1;

          function createCanvas(id) {
            const canvas = document.createElement("canvas");
            canvas.id = id; canvas.className = "grain-canvas"; overlay.appendChild(canvas);
            canvas.width = window.innerWidth * dpr; canvas.height = window.innerHeight * dpr;
            canvas.style.width = "100%"; canvas.style.height = "100%"; return canvas;
          }
          function createShader(gl, type, source) { const s = gl.createShader(type); gl.shaderSource(s, source); gl.compileShader(s); return s; }
          function createProgram(gl, vsSource, fsSource) {
            const vs = createShader(gl, gl.VERTEX_SHADER, vsSource), fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
            const p = gl.createProgram(); gl.attachShader(p, vs); gl.attachShader(p, fs); gl.linkProgram(p); return p;
          }

          const programs = layers.map(({ id, frag }) => {
            const canvas = createCanvas(id);
            const gl = canvas.getContext("webgl", { preserveDrawingBuffer: true });
            const vsSource = `attribute vec4 a_position; void main(){ gl_Position = a_position; }`;
            const fsSource = frag();
            const program = createProgram(gl, vsSource, fsSource);
            const buffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
            const aPosition = gl.getAttribLocation(program, "a_position");
            gl.enableVertexAttribArray(aPosition); gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);
            const uTime = gl.getUniformLocation(program, "u_time");
            return { gl, program, canvas, uTime };
          });

          function resize() { programs.forEach(({ gl, canvas }) => { canvas.width = window.innerWidth * dpr; canvas.height = window.innerHeight * dpr; gl.viewport(0, 0, canvas.width, canvas.height); }); }
          window.addEventListener("resize", resize); resize();

          let time = 0, last = 0; const fps = 24, step = 1000 / fps;
          function render(ts) {
            if (ts - last >= step) {
              time += 0.015; programs.forEach(({ gl, program, uTime }) => { gl.useProgram(program); gl.uniform1f(uTime, time); gl.drawArrays(gl.TRIANGLES, 0, 6); });
              last = ts;
            }
            requestAnimationFrame(render);
          }
          requestAnimationFrame(render);
        }

        function initCanvas2DGrain() {
          const canvas = document.createElement("canvas"); canvas.className = "grain-canvas"; overlay.appendChild(canvas);
          const ctx = canvas.getContext("2d");
          function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
          function generateAlphaGrain() {
            const w = canvas.width, h = canvas.height, imageData = ctx.createImageData(w, h), data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
              const isGrain = Math.random() < 0.06, alpha = isGrain ? 20 + Math.random() * 20 : 0, gray = 180 + Math.random() * 30;
              data[i] = gray; data[i + 1] = gray; data[i + 2] = gray; data[i + 3] = alpha;
            }
            ctx.putImageData(imageData, 0, 0);
          }
          resizeCanvas(); window.addEventListener("resize", resizeCanvas); setInterval(generateAlphaGrain, 1000 / 24);
        }

        function baseFrag() {
          return `
          precision mediump float; uniform float u_time;
          float random(vec2 st){ return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453); }
          void main(){ vec2 uv=gl_FragCoord.xy*1.5; float g=random(uv+u_time*10.0); float gray=0.6+g*0.3; gl_FragColor=vec4(vec3(gray), g*0.04); }`;
        }
        function floatFrag() {
          return `
          precision mediump float; uniform float u_time;
          void main(){ vec2 uv=gl_FragCoord.xy*0.002+u_time*0.02; float flow=fract(sin(dot(uv, vec2(15.1,63.8))) * 10000.0); flow=smoothstep(0.4,1.0,flow); gl_FragColor=vec4(vec3(flow), flow*0.02); }`;
        }
        function warpFrag() {
          return `
          precision mediump float; uniform float u_time;
          void main(){ vec2 uv=gl_FragCoord.xy; float shift=sin(uv.y*0.05+u_time*2.0)*0.003; float g=fract(sin(dot((uv+vec2(shift,0.0))*1.2, vec2(12.9898,78.233)))*43758.5453); vec3 gray=vec3(g); gl_FragColor=vec4(gray, g*0.03); }`;
        }
      })();
    </script>
  </section>

  <div class="page">
    <header>
      <h1>Button of Dictator</h1>
      <p class="hint">Behaviour creates consequence.</p>
      <div class="toolbar">
        <button class="btn" id="resetBtn" style="display:none">Reset logs</button>
      </div>
    </header>
    <form id="username-form">
      <input type="text" id="username" placeholder="Enter your name" required>
      <button type="submit" class="small-btn">Submit Name</button>
    </form>

    <div class="actions">
      <button id="terminate-btn">TERMINATE</button>
    </div>

    <div class="card">
      <div class="term">
        <div class="term-status">
          <span class="term-clock" id="term-clock">--:--:--</span>
          <span class="term-pos" id="term-pos">x: - y: -</span>
        </div>
        <div class="term-body" id="term-body" aria-live="polite"></div>
      </div>
    </div>

    <div class="footer">Just pull the trigger. Read the full project introduction on
      <a href="https://github.com/omnifrog-art/button-of-dictator" id="github-link" class="link" target="_blank"
        rel="noopener">
        GitHub →
      </a>
    </div>

  </div>

  <script>
    // ---- (A) 在最上面加：倒计时函数 + getApexURL 工具 ----
    async function terminalCountdown({ seconds = 10, finalText = 'farewell', redirect = 'reload' }) {
      const estimateTypeMs = (txt) => (txt?.length || 0) * 18 + 24;
      const start = performance.now();
      for (let s = seconds; s >= 1; s--) {
        const msg = `${s}s`;
        const target = start + (seconds - s + 1) * 1000;
        const budget = Math.max(0, target - performance.now() - estimateTypeMs(msg));
        if (budget > 0) await new Promise(r => setTimeout(r, budget));
        await (window.term?.println ? window.term.println(msg) : Promise.resolve());
      }
      await (window.term?.println ? window.term.println(finalText) : Promise.resolve());
      if (typeof redirect === 'function') redirect();
      else if (redirect === 'reload') location.reload();
      else if (typeof redirect === 'string' && redirect) location.replace(redirect);
    }

    function getApexURL(path = '/detached') {
      const { protocol, hostname } = location;
      if (hostname === 'localhost' || /^\d{1,3}(\.\d{1,3}){3}$/.test(hostname))
        return `${protocol}//${hostname}${path}`;
      const parts = hostname.split('.');
      const apex = parts.slice(-2).join('.');
      return `${protocol}//${apex}${path}`;
    }

    window.addEventListener('DOMContentLoaded', () => {
      const usernameForm = document.getElementById('username-form');
      const usernameInput = document.getElementById('username');
      const terminateBtn = document.getElementById('terminate-btn');

      // --- 终端安全封装（若 term 未注入也不报错） ---
      const tprintln = (msg) => (window.term && term.println) ? term.println(msg) : Promise.resolve();

      // --- 获取当前子域 ---
      function getSubdomain(host = location.hostname) {
        if (host === 'localhost' || /^\d{1,3}(\.\d{1,3}){3}$/.test(host)) return host;
        const parts = host.split('.');
        if (parts.length <= 2) return parts[0];
        return parts.slice(0, parts.length - 2).join('.');
      }

      // 页面加载时记录访问状态
      fetch('/api/update-log', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ action: 'access' })
      })
        .then(res => res.json())
        .then(data => console.log('Access logged:', data))
        .catch(console.error);

      // 提交用户名（改为 async，加入终端两行回显）
      usernameForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const username = usernameInput.value.trim();
        if (!username) {
          alert('Please enter your name.');
          await tprintln('warn: empty operator name');
          return;
        }

        try {
          const res = await fetch('/api/update-log', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ username, action: 'assign' })
          });
          const data = await res.json();
          if (!res.ok) throw new Error(data.message || 'Failed to record name');

          console.log('Name assigned:', data);

          // 终端两行（按你的文案）
          await tprintln('Name recorded');
          await tprintln(`Subdomain ${getSubdomain()} assigned to: ${username}`);

          alert('Name recorded successfully.');
        } catch (err) {
          console.error(err);
          await tprintln(`error: ${err.message || 'network error'}`);
          alert('Something went wrong: ' + (err.message || 'network error'));
        }
      });

      // 点击终结按钮 (先 terminate 成功，再 remove domain)
      terminateBtn.addEventListener('click', async () => {
        const username = usernameInput.value.trim();
        if (!username) return alert('Please submit your name first.');

        if (!confirm('Are you sure you want to TERMINATE? This action cannot be undone.')) return;

        try {
          // 文案：确认后立即输出
          await tprintln('Operation Confirmed, executing...');

          // 第一步：terminate
          const terminateRes = await fetch('/api/update-log', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ username, action: 'terminate' })
          });
          const terminateData = await terminateRes.json();
          if (!terminateRes.ok) throw new Error(terminateData.message || 'Failed to record termination');
          console.log('Terminate status updated:', terminateData);

          // 第二步：等待2秒
          await new Promise(resolve => setTimeout(resolve, 2000));

          // 第三步：确认 status
          let confirmed = false;
          let retries = 0;
          const maxRetries = 10;

          while (retries < maxRetries) {
            const checkRes = await fetch('/api/check-log-status', { cache: 'no-store' });
            const checkData = await checkRes.json();

            if (checkRes.ok && checkData.status === 'terminated') {
              confirmed = true;
              console.log('Termination confirmed.');
              break;
            }

            console.warn(`Still waiting for termination... (${retries + 1})`);
            await new Promise(resolve => setTimeout(resolve, 1000));
            retries++;
          }

          if (!confirmed) throw new Error('Failed to confirm termination status.');

          // 第四步：remove domain
          const removeRes = await fetch('/api/remove-subdomain', { method: 'POST' });
          const removeData = await removeRes.json();
          if (!removeRes.ok) throw new Error(removeData.message || 'Failed to remove subdomain');
          console.log('Subdomain removed:', removeData);

          // 文案：流程完成
          await tprintln('Detached.');
          alert('Termination complete. Subdomain removed.');
          await terminalCountdown({
            seconds: 10,
            finalText: 'farewell',
            redirect: 'reload'
          });

        } catch (error) {
          console.error('Termination process failed:', error);
          await tprintln(`error: ${error.message}`);
          alert('Something went wrong: ' + error.message);
        }
      });
    });
  </script>


  <script>
    (function () {
      const bodyEl = document.getElementById('term-body');
      if (!bodyEl) return;

      // ---- 光标 ----
      const cursor = document.createElement('span');
      cursor.id = 'term-cursor';
      cursor.textContent = '_';

      function moveCursorTo(container) {
        container.appendChild(cursor);
        bodyEl.scrollTop = bodyEl.scrollHeight;
      }

      // ---- 打字机 ----
      function typeLine(text, speed = 18) {
        return new Promise(resolve => {
          const row = document.createElement('div'); row.className = 'term-row';
          const line = document.createElement('span'); line.className = 'term-line';
          row.appendChild(line);
          bodyEl.appendChild(row);

          let i = 0;
          (function step() {
            if (i < text.length) {
              line.append(text[i++]);
              moveCursorTo(line);
              setTimeout(step, speed);
            } else {
              moveCursorTo(line);
              resolve();
            }
          })();
        });
      }

      // ---- API 暴露 ----
      window.term = {
        println: (txt) => typeLine(txt),
        newRow: () => {
          const row = document.createElement('div'); row.className = 'term-row';
          bodyEl.appendChild(row); moveCursorTo(row);
        }
      };

      // ---- 时区与时间格式工具 ----
      function getTimeZoneInfo(d = new Date()) {
        const offMin = -d.getTimezoneOffset();  // 本地相对 UTC 的偏移（分钟，东区为正）
        const sign = offMin >= 0 ? '+' : '-';
        const abs = Math.abs(offMin);
        const hh = String(Math.floor(abs / 60)).padStart(2, '0');
        const mm = String(abs % 60).padStart(2, '0');
        return { offset: `UTC${sign}${hh}:${mm}` };
      }
      function pad2(n) { return String(n).padStart(2, '0'); }
      function pad3(n) { return String(n).padStart(3, '0'); }
      function formatClock(d) {
        return `${pad2(d.getHours())}:${pad2(d.getMinutes())}:${pad2(d.getSeconds())}.${pad3(d.getMilliseconds())}`;
      }

      // ---- 状态栏：时钟（只显示时间 + UTC 偏移）----
      function updateClock() {
        const el = document.getElementById('term-clock');
        if (!el) return;
        const now = new Date();
        const { offset } = getTimeZoneInfo(now);
        el.innerHTML = `${formatClock(now)} <span class="term-muted">${offset}</span>`;
      }
      updateClock();
      setInterval(updateClock, 50);


      // ---- 状态栏：鼠标坐标（相对整个 viewport：clientX / clientY）----
      const posEl = document.getElementById('term-pos');

      // 用 rAF 合并刷新，避免高频触发抖动
      let lastX = null, lastY = null, ticking = false;

      function updatePos() {
        if (posEl && lastX != null && lastY != null) {
          // 取整，避免抖动；也可用 Math.round(lastX)
          const x = Math.max(0, lastX | 0);
          const y = Math.max(0, lastY | 0);
          posEl.innerHTML = `
  x: <span class="term-acc">${x}</span>
  y: <span class="term-acc">${y}</span>
`;

        }
        ticking = false;
      }

      function onPointerMove(e) {
        // clientX / clientY 是**相对视口**坐标（随滚动变化），符合“viewport 生效”需求
        lastX = e.clientX;
        lastY = e.clientY;
        if (!ticking) {
          ticking = true;
          requestAnimationFrame(updatePos);
        }
      }

      // 支持鼠标 & 触控（触控取首个触点）
      window.addEventListener('mousemove', onPointerMove, { passive: true });
      window.addEventListener('touchmove', (e) => {
        const t = e.touches && e.touches[0];
        if (!t) return;
        onPointerMove({ clientX: t.clientX, clientY: t.clientY });
      }, { passive: true });

      // 离开窗口时给个提示
      window.addEventListener('mouseout', (e) => {
        // 只在真正离开到浏览器外时清空
        if (!e.relatedTarget && !e.toElement) {
          if (posEl) posEl.textContent = 'x: -  y: -';
        }
      });

      // ---- 首次访问日志（第二行）----
      const accessedAt = new Date();
      window.term.println(`page accessed at ${accessedAt.toLocaleString()}`);
    })();
  </script>

<script>
(function () {
  // —— 仅在移动端、未滚动、无锚点、且尊重减少动态时退出 ——
  const ua = navigator.userAgent;
  const isMobile = /iPhone|iPad|iPod|Android/i.test(ua);
  const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
  if (!isMobile || prefersReduced || location.hash || window.scrollY > 0) return;

  let autoScrolled = false;
  let cancel = false;

  const root = document.documentElement;
  const scroller = document.scrollingElement || root;

  // 关闭原生 CSS smooth，避免与 API smooth 打架
  const prevScrollBehavior = root.style.scrollBehavior;
  root.style.scrollBehavior = 'auto';

  // 任意用户交互即取消自动滚
  ['touchstart','wheel','keydown','mousedown'].forEach(evt => {
    window.addEventListener(evt, () => { cancel = true; }, { passive:true, once:true });
  });

  // —— 工具函数 ——
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const getVH = () => window.visualViewport ? Math.round(window.visualViewport.height) : window.innerHeight;
  const canScroll = () => (scroller.scrollHeight - getVH()) > 8;

  // 等布局稳定（字体就绪 + 连续两帧 scrollHeight / VH 一致）
  async function waitStable() {
    if (document.fonts?.ready) { try { await document.fonts.ready; } catch(e){} }
    await new Promise(resolve => {
      let lastH=-1, lastV=-1, stable=0;
      const tick = () => {
        const h = scroller.scrollHeight, v = getVH();
        if (h === lastH && v === lastV) stable++; else { stable=0; lastH=h; lastV=v; }
        if (stable >= 2) resolve(); else requestAnimationFrame(tick);
      };
      requestAnimationFrame(tick);
    });
  }

  // 动画期间临时关闭重型效果（可选：若你仍想保留，解开调用处注释）
  function reduceEffects(on){
    if (on) root.classList.add('scroll-animating');
    else root.classList.remove('scroll-animating');
  }

  // 计算目标：让 .footer 的“顶边”落在视口底部之下 offsetRem（默认 0.25rem）
  function computeFooterHideBy(offsetRem = 0.25) {
    const footer = document.querySelector('.footer');
    if (!footer) return null;

    const rem = parseFloat(getComputedStyle(root).fontSize) || 16;
    const offsetPx = offsetRem * rem;
    const vh = getVH();
    const maxY = Math.max(0, scroller.scrollHeight - vh);

    const rect = footer.getBoundingClientRect();
    const currentScroll = scroller.scrollTop;
    const footerTopAbs = currentScroll + rect.top;  // 顶边

    // 让 footer 顶边位于 视口底部 + offsetPx（略藏在下方）
    const target = footerTopAbs - (vh + offsetPx);
    return clamp(Math.round(target), 0, maxY);
  }

  // —— 使用原生平滑滚动；不支持时再回退到 rAF —— 
  function scrollToYEaseOut(targetY, duration = 500) {
    if (targetY == null || !isFinite(targetY)) return;

    // 首选：原生 smooth（由合成器处理，流畅且不易掉帧）
    try {
      window.scrollTo({ top: Math.round(targetY), left: 0, behavior: 'smooth' });
      return;
    } catch (e) {
      // 老环境回退到 rAF
    }

    // 兜底：rAF（可选开启降级特效以减卡顿）
    const start = scroller.scrollTop;
    const dist = targetY - start;
    if (Math.abs(dist) < 1) return;

    const t0 = performance.now();
    const easeOut = t => 1 - Math.pow(1 - t, 3);
    let lastY = start;

    // reduceEffects(true); // ← 若需要，解开以降低毛玻璃/阴影开销
    function step(ts){
      if (cancel) { /* reduceEffects(false); */ return; }
      const p = Math.min(1, (ts - t0) / Math.max(150, duration));
      const y = start + dist * easeOut(p);
      if (Math.abs(y - lastY) > 0.5) { scroller.scrollTop = y; lastY = y; }
      if (p < 1) requestAnimationFrame(step);
      else { /* reduceEffects(false); */ }
    }
    requestAnimationFrame(step);
  }

  // 主流程：等页面稳定 → 计算 .footer 目标 → 一次性滚动
  async function run(){
    if (autoScrolled || cancel || !canScroll()) return;
    autoScrolled = true;

    // 给页面一点喘息（load→rAF→250ms→额外1.5s）
    await new Promise(r => setTimeout(r, 1000));
    await waitStable();
    if (cancel) return;

    const targetY = computeFooterHideBy(0.25); // 让 footer 顶边落在视口底下 0.25rem
    if (targetY !== null) scrollToYEaseOut(targetY, 1000);
  }

  // 首次触发
  window.addEventListener('load', () => {
    requestAnimationFrame(() => setTimeout(run, 250));
  });

  // 视口变化再尝试一次，但仍只滚“一次”
  ['orientationchange','resize','visibilitychange'].forEach(evt => {
    window.addEventListener(evt, () => {
      requestAnimationFrame(() => setTimeout(run, 150));
    }, { passive:true });
  });

  // 离开页面恢复 scroll-behavior
  window.addEventListener('pagehide', () => { root.style.scrollBehavior = prevScrollBehavior; });
})();
</script>
</body>

</html>
