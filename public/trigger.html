<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Button of Dictator</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Project stylesheet for this page -->
  <link rel="stylesheet" href="css/trigger.css" />

  <!-- Fonts aligned with the 404 background -->
  <link rel="stylesheet"
    href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@100;200;300;400;500;600;700&family=Orbitron:wght@400;500;600;700;800;900&family=Saira:wght@100;200;300;400;500;600;700;800;900&display=swap" />

  <link href="images/favicon.ico" rel="icon" type="image/x-icon" />
  <link href="images/webclip.png" rel="apple-touch-icon" />
</head>

<body>
  <section class="section-background">
    <div class="scrolling-wrapper">
      <div class="dark-frame">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" preserveAspectRatio="none"
          style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: #4d4d4d; pointer-events: none; z-index: 0;">
          <defs>
            <filter id="softEdge" x="-10%" y="-10%" width="120%" height="120%">
              <feGaussianBlur in="SourceGraphic" stdDeviation="3"></feGaussianBlur>
            </filter>
          </defs>
          <path d="
            M2,10
            C2,3 3,2 10,2
            L90,2
            C97,2 98,3 98,10
            L98,90
            C98,97 97,98 90,98
            L10,98
            C3,98 2,97 2,90
            Z" fill="#999999" filter="url(#softEdge)"></path>
        </svg>
      </div>

      <div class="scrolling-track">
        <!-- Repeated 404 text shells -->
        <div class="bg-text-shell">
          <div class="bg-clone-shell">
            <div class="bg-text-clone r">TRIGGER</div>
            <div class="bg-text-clone g">TRIGGER</div>
            <div class="bg-text-clone b">TRIGGER</div>
          </div>
          <div data-text="TERMINATED" class="bg-text">TRIGGER</div>
        </div>
        <div class="bg-text-shell">
          <div class="bg-clone-shell">
            <div class="bg-text-clone r">TRIGGER</div>
            <div class="bg-text-clone g">TRIGGER</div>
            <div class="bg-text-clone b">TRIGGER</div>
          </div>
          <div class="bg-text">TRIGGER</div>
        </div>
        <div class="bg-text-shell">
          <div class="bg-clone-shell">
            <div class="bg-text-clone r">TRIGGER</div>
            <div class="bg-text-clone g">TRIGGER</div>
            <div class="bg-text-clone b">TRIGGER</div>
          </div>
          <div class="bg-text">TRIGGER</div>
        </div>
        <div class="bg-text-shell">
          <div class="bg-clone-shell">
            <div class="bg-text-clone r">TRIGGER</div>
            <div class="bg-text-clone g">TRIGGER</div>
            <div class="bg-text-clone b">TRIGGER</div>
          </div>
          <div class="bg-text">TRIGGER</div>
        </div>
        <div class="bg-text-shell">
          <div class="bg-clone-shell">
            <div class="bg-text-clone r">TRIGGER</div>
            <div class="bg-text-clone g">TRIGGER</div>
            <div class="bg-text-clone b">TRIGGER</div>
          </div>
          <div class="bg-text">TRIGGER</div>
        </div>
        <div class="bg-text-shell">
          <div class="bg-clone-shell">
            <div class="bg-text-clone r">TRIGGER</div>
            <div class="bg-text-clone g">TRIGGER</div>
            <div class="bg-text-clone b">TRIGGER</div>
          </div>
          <div class="bg-text">TRIGGER</div>
        </div>
        <div class="bg-text-shell">
          <div class="bg-clone-shell">
            <div class="bg-text-clone r">TRIGGER</div>
            <div class="bg-text-clone g">TRIGGER</div>
            <div class="bg-text-clone b">TRIGGER</div>
          </div>
          <div class="bg-text">TRIGGER</div>
        </div>

        <script>
          (function () {
            const track = document.querySelector('.scrolling-track');
            if (!track) return;

            const shells = Array.from(track.querySelectorAll('.bg-text-shell'));
            const items = Array.from(track.querySelectorAll('.bg-text'));

            // 动画参数
            const speed = 0.5;                 // px/帧（你原先的速度）
            let step = 0;                    // 一次完整循环应位移的距离
            let pos = 0;                    // 当前 translateX 偏移（正值向左）
            let rafId = null;

            // 用户减少动画偏好
            const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

            // 等字体就绪，再测量（fallback 安全）
            async function waitForFonts() {
              if (document.fonts && document.fonts.ready) {
                try { await document.fonts.ready; } catch (e) { }
              }
              // 再等两帧，确保回流完成
              await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
            }

            // 计算循环步长：用相邻两个 shell 的 offsetLeft 之差
            function computeStep() {
              if (shells.length >= 2) {
                const a = shells[0].offsetLeft;
                const b = shells[1].offsetLeft;
                const d = b - a;
                if (d > 0) return d;
              }
              // 兜底：文字宽度 + 10vw（与旧逻辑一致）
              const itemWidth = items[0]?.offsetWidth || 0;
              const gap = window.innerWidth * 0.1;
              return itemWidth + gap;
            }

            function applyTransform() {
              // 用模运算平滑回环；注意是负方向平移
              const wrapped = ((pos % step) + step) % step;
              track.style.transform = `translateX(${-wrapped}px)`;
            }

            function tick() {
              pos += speed;
              applyTransform();
              rafId = requestAnimationFrame(tick);
            }

            // 重新测量（窗口变化/字体变化时）
            function remeasure() {
              const oldStep = step;
              step = computeStep();
              if (step <= 0) return;

              // 将当前位置按新步长重新包裹，避免跳变
              pos = ((pos % step) + step) % step;
              applyTransform();
            }

            // 初始化
            (async function init() {
              // 初始透明度淡入（保持你原来的效果）
              items.forEach(el => { el.style.opacity = '0'; el.style.transition = 'opacity 1s ease-out'; });

              await waitForFonts();
              step = computeStep();
              applyTransform();

              // 1s 后开始动画（沿用你的时序）
              setTimeout(() => {
                if (!prefersReduced) rafId = requestAnimationFrame(tick);
                items.forEach(el => { el.style.opacity = '1'; });
              }, 1000);

              // 监听 resize（含 DPR 变化）
              let resizeTimer = null;
              window.addEventListener('resize', () => {
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(remeasure, 50);
              });

              // 字体集合事件（部分浏览器支持）
              if (document.fonts && typeof document.fonts.addEventListener === 'function') {
                document.fonts.addEventListener('loadingdone', remeasure);
                document.fonts.addEventListener('loadingerror', remeasure);
              }
            })();
          })();
        </script>


        <style>
          .bg-text,
          .bg-text-clone {
            pointer-events: none;
            will-change: transform, opacity;
          }

          .bg-text-clone {
            opacity: 0;
            transition: transform 0.05s ease, opacity 0.1s ease;
            mix-blend-mode: screen;
            z-index: 0;
          }
        </style>

        <script>
          document.addEventListener("DOMContentLoaded", () => {
            const shells = document.querySelectorAll('.bg-text-shell');
            let isCrtRunning = false;
            let tinyGlitchTimer = null;
            let bigGlitchTimer = null;

            function clearClones() {
              shells.forEach(shell => {
                shell.querySelectorAll('.bg-text-clone').forEach(clone => {
                  clone.style.opacity = 0;
                  clone.style.transform = 'translate(0, 0) scale(1)';
                  clone.style.filter = 'none';
                });
              });
            }
            function doTinyGlitch() {
              if (isCrtRunning) return;
              shells.forEach(shell => {
                const clones = shell.querySelectorAll('.bg-text-clone');
                const offsetX = () => (Math.random() * 12 - 6) + "px";
                const offsetY = () => (Math.random() * 12 - 6) + "px";
                const randomOpacity = 0.15 + Math.random() * 0.1;
                clones.forEach(clone => {
                  clone.style.opacity = randomOpacity.toFixed(2);
                  clone.style.transform = `translate(${offsetX()}, ${offsetY()})`;
                  clone.style.filter = "none";
                });
                setTimeout(() => {
                  clones.forEach(clone => {
                    clone.style.opacity = 0;
                    clone.style.transform = `translate(0, 0)`;
                  });
                }, 200);
              });
            }
            function scheduleTinyGlitch() {
              if (tinyGlitchTimer) clearTimeout(tinyGlitchTimer);
              if (isCrtRunning) return;
              doTinyGlitch();
              tinyGlitchTimer = setTimeout(scheduleTinyGlitch, Math.random() * 1000 + 1000);
            }
            function doBigGlitchOnce() {
              shells.forEach(shell => {
                const clones = shell.querySelectorAll('.bg-text-clone');
                const offsetX = () => (Math.random() * 100 - 50) + "px";
                const offsetY = () => (Math.random() * 100 - 50) + "px";
                const randomOpacity = 0.7 + Math.random() * 0.25;
                clones.forEach(clone => {
                  clone.style.opacity = randomOpacity.toFixed(2);
                  clone.style.transform = `translate(${offsetX()}, ${offsetY()}) scale(${1 + Math.random() * 0.08})`;
                  clone.style.filter = "blur(0.6px) contrast(150%)";
                });
                setTimeout(() => {
                  clones.forEach(clone => {
                    clone.style.opacity = 0;
                    clone.style.transform = `translate(0, 0) scale(1)`;
                    clone.style.filter = "none";
                  });
                }, 180);
              });
            }
            function scheduleBigGlitch() {
              if (bigGlitchTimer) clearTimeout(bigGlitchTimer);
              if (isCrtRunning) return;
              const blastCount = Math.floor(Math.random() * 3) + 1;
              let delay = 0;
              for (let i = 0; i < blastCount; i++) {
                setTimeout(() => { if (!isCrtRunning) doBigGlitchOnce(); }, delay);
                delay += 160 + Math.random() * 40;
              }
              const nextDelay = delay + Math.random() * 3000 + 3000;
              bigGlitchTimer = setTimeout(scheduleBigGlitch, nextDelay);
            }
            function startGlitches() { scheduleTinyGlitch(); scheduleBigGlitch(); }
            function stopGlitches() {
              clearTimeout(tinyGlitchTimer); clearTimeout(bigGlitchTimer);
              tinyGlitchTimer = null; bigGlitchTimer = null; clearClones();
            }
            function crtEffect() {
              isCrtRunning = true; stopGlitches();
              shells.forEach(shell => {
                const texts = shell.querySelectorAll('.bg-text, .bg-text-clone');
                texts.forEach(text => {
                  text.style.transition = "none";
                  text.style.transform = "scaleY(1) scaleX(1) translate(0, 0)";
                  text.style.opacity = "1"; text.style.filter = "none";
                });
                setTimeout(() => {
                  texts.forEach(text => {
                    if (text.classList.contains('bg-text-clone')) {
                      text.style.transition = "opacity 0.2s ease-out, transform 0.2s ease-in";
                      text.style.opacity = "0"; text.style.transform = "scaleY(0.05) scaleX(1)";
                    } else {
                      text.style.transition = "transform 0.2s ease-in";
                      text.style.transform = "scaleY(0.05) scaleX(1)"; text.style.opacity = "1";
                    }
                  });
                }, 10);
                setTimeout(() => {
                  texts.forEach(text => {
                    text.style.transition = "transform 0.1s ease-in, opacity 0.1s ease-out";
                    text.style.transform = "scaleY(0.05) scaleX(0)"; text.style.opacity = "0";
                  });
                }, 210);
                setTimeout(() => {
                  texts.forEach(text => {
                    text.style.transition = "opacity 3s ease-out, transform 0s";
                    text.style.transform = "scaleY(1) scaleX(1)"; text.style.opacity = "1";
                  });
                  isCrtRunning = false; startGlitches();
                }, 1800);
              });
            }
            setTimeout(() => { crtEffect(); setInterval(crtEffect, 12000); }, 3000);
          });
        </script>
      </div>
    </div>

    <div class="glass-layer"></div>

    <div class="grain-overlay"></div>

    <script>
      (function () {
        const overlay = document.querySelector(".grain-overlay");
        if (!overlay) return;
        const style = document.createElement('style');
        style.textContent = `
          .grain-overlay { pointer-events: none; opacity: 0.15; }
          .grain-overlay canvas {
            width: 100%; height: 100%; display: block; position: absolute; top: 0; left: 0;
            image-rendering: pixelated;
          }`;
        document.head.appendChild(style);

        if (supportsWebGL()) { initWebGLGrain(); } else { initCanvas2DGrain(); }

        function supportsWebGL() { try { const c = document.createElement("canvas"); return !!window.WebGLRenderingContext && c.getContext("webgl"); } catch (e) { return false; } }

        function initWebGLGrain() {
          const layers = [
            { id: "grain-base", frag: baseFrag },
            { id: "grain-float", frag: floatFrag },
            { id: "grain-warp", frag: warpFrag }
          ];
          const dpr = window.devicePixelRatio || 1;

          function createCanvas(id) {
            const canvas = document.createElement("canvas");
            canvas.id = id; canvas.className = "grain-canvas"; overlay.appendChild(canvas);
            canvas.width = window.innerWidth * dpr; canvas.height = window.innerHeight * dpr;
            canvas.style.width = "100%"; canvas.style.height = "100%"; return canvas;
          }
          function createShader(gl, type, source) { const s = gl.createShader(type); gl.shaderSource(s, source); gl.compileShader(s); return s; }
          function createProgram(gl, vsSource, fsSource) {
            const vs = createShader(gl, gl.VERTEX_SHADER, vsSource), fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
            const p = gl.createProgram(); gl.attachShader(p, vs); gl.attachShader(p, fs); gl.linkProgram(p); return p;
          }

          const programs = layers.map(({ id, frag }) => {
            const canvas = createCanvas(id);
            const gl = canvas.getContext("webgl", { preserveDrawingBuffer: true });
            const vsSource = `attribute vec4 a_position; void main(){ gl_Position = a_position; }`;
            const fsSource = frag();
            const program = createProgram(gl, vsSource, fsSource);
            const buffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
            const aPosition = gl.getAttribLocation(program, "a_position");
            gl.enableVertexAttribArray(aPosition); gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);
            const uTime = gl.getUniformLocation(program, "u_time");
            return { gl, program, canvas, uTime };
          });

          function resize() { programs.forEach(({ gl, canvas }) => { canvas.width = window.innerWidth * dpr; canvas.height = window.innerHeight * dpr; gl.viewport(0, 0, canvas.width, canvas.height); }); }
          window.addEventListener("resize", resize); resize();

          let time = 0, last = 0; const fps = 24, step = 1000 / fps;
          function render(ts) {
            if (ts - last >= step) {
              time += 0.015; programs.forEach(({ gl, program, uTime }) => { gl.useProgram(program); gl.uniform1f(uTime, time); gl.drawArrays(gl.TRIANGLES, 0, 6); });
              last = ts;
            }
            requestAnimationFrame(render);
          }
          requestAnimationFrame(render);
        }

        function initCanvas2DGrain() {
          const canvas = document.createElement("canvas"); canvas.className = "grain-canvas"; overlay.appendChild(canvas);
          const ctx = canvas.getContext("2d");
          function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
          function generateAlphaGrain() {
            const w = canvas.width, h = canvas.height, imageData = ctx.createImageData(w, h), data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
              const isGrain = Math.random() < 0.06, alpha = isGrain ? 20 + Math.random() * 20 : 0, gray = 180 + Math.random() * 30;
              data[i] = gray; data[i + 1] = gray; data[i + 2] = gray; data[i + 3] = alpha;
            }
            ctx.putImageData(imageData, 0, 0);
          }
          resizeCanvas(); window.addEventListener("resize", resizeCanvas); setInterval(generateAlphaGrain, 1000 / 24);
        }

        function baseFrag() {
          return `
          precision mediump float; uniform float u_time;
          float random(vec2 st){ return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453); }
          void main(){ vec2 uv=gl_FragCoord.xy*1.5; float g=random(uv+u_time*10.0); float gray=0.6+g*0.3; gl_FragColor=vec4(vec3(gray), g*0.04); }`;
        }
        function floatFrag() {
          return `
          precision mediump float; uniform float u_time;
          void main(){ vec2 uv=gl_FragCoord.xy*0.002+u_time*0.02; float flow=fract(sin(dot(uv, vec2(15.1,63.8))) * 10000.0); flow=smoothstep(0.4,1.0,flow); gl_FragColor=vec4(vec3(flow), flow*0.02); }`;
        }
        function warpFrag() {
          return `
          precision mediump float; uniform float u_time;
          void main(){ vec2 uv=gl_FragCoord.xy; float shift=sin(uv.y*0.05+u_time*2.0)*0.003; float g=fract(sin(dot((uv+vec2(shift,0.0))*1.2, vec2(12.9898,78.233)))*43758.5453); vec3 gray=vec3(g); gl_FragColor=vec4(gray, g*0.03); }`;
        }
      })();
    </script>
  </section>



  <div class="page">

    <h1>Button of Dictator</h1>

    <form id="username-form">
      <input type="text" id="username" placeholder="Enter your name" required>
      <button type="submit" class="small-btn">Submit Name</button>
    </form>

    <div class="actions">
      <button id="terminate-btn">Terminate</button>
    </div>

<div class="card">
  <div class="term">
    <div class="term-status">
      <span class="term-clock" id="term-clock">--:--:--</span>
      <span class="term-pos" id="term-pos">x: -  y: -</span>
    </div>
    <div class="term-body" id="term-body" aria-live="polite"></div>
  </div>
</div>

  </div>

<script>
// === Supabase 实例，若 log.js 里已有可直接复用 ===
const SUPABASE_URL = 'https://qvslxmokvbjhslbxdhtb.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InF2c2x4bW9rdmJqaHNsYnhkaHRiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDU2ODM1MzYsImV4cCI6MjA2MTI1OTUzNn0.fJ9jTo9yrKWZQ-Hif2-YJo5jWF1RolIsIeZSVB5TPxA';
const supabase = window.supabase || createClient(supabaseUrl, supabaseKey);

// === 工具：取当前 subdomain ===
function getSubdomain(host = location.hostname) {
  if (host === 'localhost' || /^\d{1,3}(\.\d{1,3}){3}$/.test(host)) return host;
  const parts = host.split('.');
  if (parts.length <= 2) return parts[0];
  return parts.slice(0, parts.length - 2).join('.');
}

// === 初始化 assign 状态 ===
async function initAssignLockFromSupabase() {
  const sub = getSubdomain();
  const { data, error } = await supabase
    .from('logs')
    .select('assignedTo')
    .eq('subdomain', sub)
    .single();

  if (error) {
    console.warn('Supabase check error:', error.message);
    return;
  }

  if (data && data.assignedTo) {
    // 已有操作者 → 锁 UI 并打印
    const operator = data.assignedTo;
    usernameInput.disabled = true;
    const submitBtn = usernameForm.querySelector('button[type="submit"]');
    if (submitBtn) submitBtn.disabled = true;

    await (window.term?.println
      ? term.println(`Subdomain ${sub} already assigned to: ${operator}`)
      : Promise.resolve());
  } else {
    // 无人占用 → 保持开放
    usernameInput.disabled = false;
    const submitBtn = usernameForm.querySelector('button[type="submit"]');
    if (submitBtn) submitBtn.disabled = false;
  }
}

// 页面加载完后调用
window.addEventListener('DOMContentLoaded', () => {
  initAssignLockFromSupabase();
});

  window.addEventListener('DOMContentLoaded', () => {
    const usernameForm = document.getElementById('username-form');
    const usernameInput = document.getElementById('username');
    const terminateBtn = document.getElementById('terminate-btn');

    // --- 终端安全封装（若 term 未注入也不报错） ---
    const tprintln = (msg) => (window.term && term.println) ? term.println(msg) : Promise.resolve();

    // --- 获取当前子域 ---
    function getSubdomain(host = location.hostname) {
      if (host === 'localhost' || /^\d{1,3}(\.\d{1,3}){3}$/.test(host)) return host;
      const parts = host.split('.');
      if (parts.length <= 2) return parts[0];
      return parts.slice(0, parts.length - 2).join('.');
    }

    // 页面加载时记录访问状态
    fetch('/api/update-log', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ action: 'access' })
    })
      .then(res => res.json())
      .then(data => console.log('Access logged:', data))
      .catch(console.error);

    // 提交用户名（改为 async，加入终端两行回显）
    usernameForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      const username = usernameInput.value.trim();
      if (!username) {
        alert('Please enter your name.');
        await tprintln('warn: empty operator name');
        return;
      }

      try {
        const res = await fetch('/api/update-log', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ username, action: 'assign' })
        });
        const data = await res.json();
        if (!res.ok) throw new Error(data.message || 'Failed to record name');

        console.log('Name assigned:', data);

        // 终端两行（按你的文案）
        await tprintln('Name recorded');
        await tprintln(`Subdomain ${getSubdomain()} assigned to: ${username}`);

        alert('Name recorded successfully.');
      } catch (err) {
        console.error(err);
        await tprintln(`error: ${err.message || 'network error'}`);
        alert('Something went wrong: ' + (err.message || 'network error'));
      }
    });

    // 点击终结按钮 (先 terminate 成功，再 remove domain)
    terminateBtn.addEventListener('click', async () => {
      const username = usernameInput.value.trim();
      if (!username) return alert('Please submit your name first.');

      if (!confirm('Are you sure you want to TERMINATE? This action cannot be undone.')) return;

      try {
        // 文案：确认后立即输出
        await tprintln('Operation Confirmed, executing...');

        // 第一步：terminate
        const terminateRes = await fetch('/api/update-log', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ username, action: 'terminate' })
        });
        const terminateData = await terminateRes.json();
        if (!terminateRes.ok) throw new Error(terminateData.message || 'Failed to record termination');
        console.log('Terminate status updated:', terminateData);

        // 第二步：等待2秒
        await new Promise(resolve => setTimeout(resolve, 2000));

        // 第三步：确认 status
        let confirmed = false;
        let retries = 0;
        const maxRetries = 10;

        while (retries < maxRetries) {
          const checkRes = await fetch('/api/check-log-status', { cache: 'no-store' });
          const checkData = await checkRes.json();

          if (checkRes.ok && checkData.status === 'terminated') {
            confirmed = true;
            console.log('Termination confirmed.');
            break;
          }

          console.warn(`Still waiting for termination... (${retries + 1})`);
          await new Promise(resolve => setTimeout(resolve, 1000));
          retries++;
        }

        if (!confirmed) throw new Error('Failed to confirm termination status.');

        // 第四步：remove domain
        const removeRes = await fetch('/api/remove-subdomain', { method: 'POST' });
        const removeData = await removeRes.json();
        if (!removeRes.ok) throw new Error(removeData.message || 'Failed to remove subdomain');
        console.log('Subdomain removed:', removeData);

        // 文案：流程完成
        await tprintln('Detached.');

        alert('Termination complete. Subdomain removed.');
        setTimeout(() => window.location.reload(), 10000);

      } catch (error) {
        console.error('Termination process failed:', error);
        await tprintln(`error: ${error.message}`);
        alert('Something went wrong: ' + error.message);
      }
    });
  });
</script>


  <script>
(function(){
  const bodyEl = document.getElementById('term-body');
  if (!bodyEl) return;

  // ---- 光标 ----
  const cursor = document.createElement('span');
  cursor.id = 'term-cursor';
  cursor.textContent = '_';

  function moveCursorTo(container) {
    container.appendChild(cursor);
    bodyEl.scrollTop = bodyEl.scrollHeight;
  }

  // ---- 打字机 ----
  function typeLine(text, speed = 18) {
    return new Promise(resolve => {
      const row  = document.createElement('div'); row.className = 'term-row';
      const line = document.createElement('span'); line.className = 'term-line';
      row.appendChild(line);
      bodyEl.appendChild(row);

      let i = 0;
      (function step() {
        if (i < text.length) {
          line.append(text[i++]);
          moveCursorTo(line);
          setTimeout(step, speed);
        } else {
          moveCursorTo(line);
          resolve();
        }
      })();
    });
  }

  // ---- API 暴露 ----
  window.term = {
    println: (txt) => typeLine(txt),
    newRow: () => {
      const row = document.createElement('div'); row.className = 'term-row';
      bodyEl.appendChild(row); moveCursorTo(row);
    }
  };

// ---- 时区与时间格式工具 ----
function getTimeZoneInfo(d = new Date()){
  const offMin = -d.getTimezoneOffset();  // 本地相对 UTC 的偏移（分钟，东区为正）
  const sign   = offMin >= 0 ? '+' : '-';
  const abs    = Math.abs(offMin);
  const hh     = String(Math.floor(abs / 60)).padStart(2, '0');
  const mm     = String(abs % 60).padStart(2, '0');
  return { offset: `UTC${sign}${hh}:${mm}` };
}
function pad2(n){ return String(n).padStart(2,'0'); }
function pad3(n){ return String(n).padStart(3,'0'); }
function formatClock(d){
  return `${pad2(d.getHours())}:${pad2(d.getMinutes())}:${pad2(d.getSeconds())}.${pad3(d.getMilliseconds())}`;
}

// ---- 状态栏：时钟（只显示时间 + UTC 偏移）----
function updateClock(){
  const el = document.getElementById('term-clock');
  if (!el) return;
  const now = new Date();
  const { offset } = getTimeZoneInfo(now);
  el.textContent = `${formatClock(now)}   ${offset}`;
}
updateClock();
setInterval(updateClock, 50);


// ---- 状态栏：鼠标坐标（相对整个 viewport：clientX / clientY）----
const posEl = document.getElementById('term-pos');

// 用 rAF 合并刷新，避免高频触发抖动
let lastX = null, lastY = null, ticking = false;

function updatePos() {
  if (posEl && lastX != null && lastY != null) {
    // 取整，避免抖动；也可用 Math.round(lastX)
    const x = Math.max(0, lastX | 0);
    const y = Math.max(0, lastY | 0);
    posEl.textContent = `x: ${x}  y: ${y}`;
  }
  ticking = false;
}

function onPointerMove(e) {
  // clientX / clientY 是**相对视口**坐标（随滚动变化），符合“viewport 生效”需求
  lastX = e.clientX;
  lastY = e.clientY;
  if (!ticking) {
    ticking = true;
    requestAnimationFrame(updatePos);
  }
}

// 支持鼠标 & 触控（触控取首个触点）
window.addEventListener('mousemove', onPointerMove, { passive: true });
window.addEventListener('touchmove', (e) => {
  const t = e.touches && e.touches[0];
  if (!t) return;
  onPointerMove({ clientX: t.clientX, clientY: t.clientY });
}, { passive: true });

// 离开窗口时给个提示
window.addEventListener('mouseout', (e) => {
  // 只在真正离开到浏览器外时清空
  if (!e.relatedTarget && !e.toElement) {
    if (posEl) posEl.textContent = 'x: -  y: -';
  }
});

  // ---- 首次访问日志（第二行）----
  const accessedAt = new Date();
  window.term.println(`page accessed at ${accessedAt.toLocaleString()}`);
})();
</script>

</body>

</html>
