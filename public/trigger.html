<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Button of Dictator</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Project stylesheet for this page -->
  <link rel="stylesheet" href="css/trigger.css" />

  <!-- Fonts aligned with the 404 background -->
  <link rel="stylesheet"
    href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@100;200;300;400;500;600;700&family=Orbitron:wght@400;500;600;700;800;900&family=Saira:wght@100;200;300;400;500;600;700;800;900&display=swap" />

  <link href="images/favicon.ico" rel="icon" type="image/x-icon" />
  <link href="images/webclip.png" rel="apple-touch-icon" />
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>

<body>
  <section class="section-background">
    <div class="scrolling-wrapper">
      <div class="dark-frame">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" preserveAspectRatio="none"
          style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: #4d4d4d; pointer-events: none; z-index: 0;">
          <defs>
            <filter id="softEdge" x="-10%" y="-10%" width="120%" height="120%">
              <feGaussianBlur in="SourceGraphic" stdDeviation="3"></feGaussianBlur>
            </filter>
          </defs>
          <path d="
            M2,10
            C2,3 3,2 10,2
            L90,2
            C97,2 98,3 98,10
            L98,90
            C98,97 97,98 90,98
            L10,98
            C3,98 2,97 2,90
            Z" fill="#999999" filter="url(#softEdge)"></path>
        </svg>
      </div>

      <div class="scrolling-track">
        <!-- Repeated 404 text shells -->
        <div class="bg-text-shell">
          <div class="bg-clone-shell">
            <div class="bg-text-clone r">TRIGGER</div>
            <div class="bg-text-clone g">TRIGGER</div>
            <div class="bg-text-clone b">TRIGGER</div>
          </div>
          <div data-text="TERMINATED" class="bg-text">TRIGGER</div>
        </div>
        <div class="bg-text-shell">
          <div class="bg-clone-shell">
            <div class="bg-text-clone r">TRIGGER</div>
            <div class="bg-text-clone g">TRIGGER</div>
            <div class="bg-text-clone b">TRIGGER</div>
          </div>
          <div class="bg-text">TRIGGER</div>
        </div>
        <div class="bg-text-shell">
          <div class="bg-clone-shell">
            <div class="bg-text-clone r">TRIGGER</div>
            <div class="bg-text-clone g">TRIGGER</div>
            <div class="bg-text-clone b">TRIGGER</div>
          </div>
          <div class="bg-text">TRIGGER</div>
        </div>
        <div class="bg-text-shell">
          <div class="bg-clone-shell">
            <div class="bg-text-clone r">TRIGGER</div>
            <div class="bg-text-clone g">TRIGGER</div>
            <div class="bg-text-clone b">TRIGGER</div>
          </div>
          <div class="bg-text">TRIGGER</div>
        </div>
        <div class="bg-text-shell">
          <div class="bg-clone-shell">
            <div class="bg-text-clone r">TRIGGER</div>
            <div class="bg-text-clone g">TRIGGER</div>
            <div class="bg-text-clone b">TRIGGER</div>
          </div>
          <div class="bg-text">TRIGGER</div>
        </div>
        <div class="bg-text-shell">
          <div class="bg-clone-shell">
            <div class="bg-text-clone r">TRIGGER</div>
            <div class="bg-text-clone g">TRIGGER</div>
            <div class="bg-text-clone b">TRIGGER</div>
          </div>
          <div class="bg-text">TRIGGER</div>
        </div>
        <div class="bg-text-shell">
          <div class="bg-clone-shell">
            <div class="bg-text-clone r">TRIGGER</div>
            <div class="bg-text-clone g">TRIGGER</div>
            <div class="bg-text-clone b">TRIGGER</div>
          </div>
          <div class="bg-text">TRIGGER</div>
        </div>

        <script>
          (function () {
            const track = document.querySelector('.scrolling-track');
            if (!track) return;

            const shells = Array.from(track.querySelectorAll('.bg-text-shell'));
            const items = Array.from(track.querySelectorAll('.bg-text'));

            // 动画参数
            const speed = 0.5;                 // px/帧（你原先的速度）
            let step = 0;                    // 一次完整循环应位移的距离
            let pos = 0;                    // 当前 translateX 偏移（正值向左）
            let rafId = null;

            // 用户减少动画偏好
            const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

            // 等字体就绪，再测量（fallback 安全）
            async function waitForFonts() {
              if (document.fonts && document.fonts.ready) {
                try { await document.fonts.ready; } catch (e) { }
              }
              // 再等两帧，确保回流完成
              await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
            }

            // 计算循环步长：用相邻两个 shell 的 offsetLeft 之差
            function computeStep() {
              if (shells.length >= 2) {
                const a = shells[0].offsetLeft;
                const b = shells[1].offsetLeft;
                const d = b - a;
                if (d > 0) return d;
              }
              // 兜底：文字宽度 + 10vw（与旧逻辑一致）
              const itemWidth = items[0]?.offsetWidth || 0;
              const gap = window.innerWidth * 0.1;
              return itemWidth + gap;
            }

            function applyTransform() {
              // 用模运算平滑回环；注意是负方向平移
              const wrapped = ((pos % step) + step) % step;
              track.style.transform = `translateX(${-wrapped}px)`;
            }

            function tick() {
              pos += speed;
              applyTransform();
              rafId = requestAnimationFrame(tick);
            }

            // 重新测量（窗口变化/字体变化时）
            function remeasure() {
              const oldStep = step;
              step = computeStep();
              if (step <= 0) return;

              // 将当前位置按新步长重新包裹，避免跳变
              pos = ((pos % step) + step) % step;
              applyTransform();
            }

            // 初始化
            (async function init() {
              // 初始透明度淡入（保持你原来的效果）
              items.forEach(el => { el.style.opacity = '0'; el.style.transition = 'opacity 1s ease-out'; });

              await waitForFonts();
              step = computeStep();
              applyTransform();

              // 1s 后开始动画（沿用你的时序）
              setTimeout(() => {
                if (!prefersReduced) rafId = requestAnimationFrame(tick);
                items.forEach(el => { el.style.opacity = '1'; });
              }, 1000);

              // 监听 resize（含 DPR 变化）
              let resizeTimer = null;
              window.addEventListener('resize', () => {
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(remeasure, 50);
              });

              // 字体集合事件（部分浏览器支持）
              if (document.fonts && typeof document.fonts.addEventListener === 'function') {
                document.fonts.addEventListener('loadingdone', remeasure);
                document.fonts.addEventListener('loadingerror', remeasure);
              }
            })();
          })();
        </script>


        <style>
          .bg-text,
          .bg-text-clone {
            pointer-events: none;
            will-change: transform, opacity;
          }

          .bg-text-clone {
            opacity: 0;
            transition: transform 0.05s ease, opacity 0.1s ease;
            mix-blend-mode: screen;
            z-index: 0;
          }
        </style>

        <script>
          document.addEventListener("DOMContentLoaded", () => {
            const shells = document.querySelectorAll('.bg-text-shell');
            let isCrtRunning = false;
            let tinyGlitchTimer = null;
            let bigGlitchTimer = null;

            function clearClones() {
              shells.forEach(shell => {
                shell.querySelectorAll('.bg-text-clone').forEach(clone => {
                  clone.style.opacity = 0;
                  clone.style.transform = 'translate(0, 0) scale(1)';
                  clone.style.filter = 'none';
                });
              });
            }
            function doTinyGlitch() {
              if (isCrtRunning) return;
              shells.forEach(shell => {
                const clones = shell.querySelectorAll('.bg-text-clone');
                const offsetX = () => (Math.random() * 12 - 6) + "px";
                const offsetY = () => (Math.random() * 12 - 6) + "px";
                const randomOpacity = 0.15 + Math.random() * 0.1;
                clones.forEach(clone => {
                  clone.style.opacity = randomOpacity.toFixed(2);
                  clone.style.transform = `translate(${offsetX()}, ${offsetY()})`;
                  clone.style.filter = "none";
                });
                setTimeout(() => {
                  clones.forEach(clone => {
                    clone.style.opacity = 0;
                    clone.style.transform = `translate(0, 0)`;
                  });
                }, 200);
              });
            }
            function scheduleTinyGlitch() {
              if (tinyGlitchTimer) clearTimeout(tinyGlitchTimer);
              if (isCrtRunning) return;
              doTinyGlitch();
              tinyGlitchTimer = setTimeout(scheduleTinyGlitch, Math.random() * 1000 + 1000);
            }
            function doBigGlitchOnce() {
              shells.forEach(shell => {
                const clones = shell.querySelectorAll('.bg-text-clone');
                const offsetX = () => (Math.random() * 100 - 50) + "px";
                const offsetY = () => (Math.random() * 100 - 50) + "px";
                const randomOpacity = 0.7 + Math.random() * 0.25;
                clones.forEach(clone => {
                  clone.style.opacity = randomOpacity.toFixed(2);
                  clone.style.transform = `translate(${offsetX()}, ${offsetY()}) scale(${1 + Math.random() * 0.08})`;
                  clone.style.filter = "blur(0.6px) contrast(150%)";
                });
                setTimeout(() => {
                  clones.forEach(clone => {
                    clone.style.opacity = 0;
                    clone.style.transform = `translate(0, 0) scale(1)`;
                    clone.style.filter = "none";
                  });
                }, 180);
              });
            }
            function scheduleBigGlitch() {
              if (bigGlitchTimer) clearTimeout(bigGlitchTimer);
              if (isCrtRunning) return;
              const blastCount = Math.floor(Math.random() * 3) + 1;
              let delay = 0;
              for (let i = 0; i < blastCount; i++) {
                setTimeout(() => { if (!isCrtRunning) doBigGlitchOnce(); }, delay);
                delay += 160 + Math.random() * 40;
              }
              const nextDelay = delay + Math.random() * 3000 + 3000;
              bigGlitchTimer = setTimeout(scheduleBigGlitch, nextDelay);
            }
            function startGlitches() { scheduleTinyGlitch(); scheduleBigGlitch(); }
            function stopGlitches() {
              clearTimeout(tinyGlitchTimer); clearTimeout(bigGlitchTimer);
              tinyGlitchTimer = null; bigGlitchTimer = null; clearClones();
            }
            function crtEffect() {
              isCrtRunning = true; stopGlitches();
              shells.forEach(shell => {
                const texts = shell.querySelectorAll('.bg-text, .bg-text-clone');
                texts.forEach(text => {
                  text.style.transition = "none";
                  text.style.transform = "scaleY(1) scaleX(1) translate(0, 0)";
                  text.style.opacity = "1"; text.style.filter = "none";
                });
                setTimeout(() => {
                  texts.forEach(text => {
                    if (text.classList.contains('bg-text-clone')) {
                      text.style.transition = "opacity 0.2s ease-out, transform 0.2s ease-in";
                      text.style.opacity = "0"; text.style.transform = "scaleY(0.05) scaleX(1)";
                    } else {
                      text.style.transition = "transform 0.2s ease-in";
                      text.style.transform = "scaleY(0.05) scaleX(1)"; text.style.opacity = "1";
                    }
                  });
                }, 10);
                setTimeout(() => {
                  texts.forEach(text => {
                    text.style.transition = "transform 0.1s ease-in, opacity 0.1s ease-out";
                    text.style.transform = "scaleY(0.05) scaleX(0)"; text.style.opacity = "0";
                  });
                }, 210);
                setTimeout(() => {
                  texts.forEach(text => {
                    text.style.transition = "opacity 3s ease-out, transform 0s";
                    text.style.transform = "scaleY(1) scaleX(1)"; text.style.opacity = "1";
                  });
                  isCrtRunning = false; startGlitches();
                }, 1800);
              });
            }
            setTimeout(() => { crtEffect(); setInterval(crtEffect, 12000); }, 3000);
          });
        </script>
      </div>
    </div>

    <div class="glass-layer"></div>

    <div class="grain-overlay"></div>

    <script>
      (function () {
        const overlay = document.querySelector(".grain-overlay");
        if (!overlay) return;
        const style = document.createElement('style');
        style.textContent = `
          .grain-overlay { pointer-events: none; opacity: 0.15; }
          .grain-overlay canvas {
            width: 100%; height: 100%; display: block; position: absolute; top: 0; left: 0;
            image-rendering: pixelated;
          }`;
        document.head.appendChild(style);

        if (supportsWebGL()) { initWebGLGrain(); } else { initCanvas2DGrain(); }

        function supportsWebGL() { try { const c = document.createElement("canvas"); return !!window.WebGLRenderingContext && c.getContext("webgl"); } catch (e) { return false; } }

        function initWebGLGrain() {
          const layers = [
            { id: "grain-base", frag: baseFrag },
            { id: "grain-float", frag: floatFrag },
            { id: "grain-warp", frag: warpFrag }
          ];
          const dpr = window.devicePixelRatio || 1;

          function createCanvas(id) {
            const canvas = document.createElement("canvas");
            canvas.id = id; canvas.className = "grain-canvas"; overlay.appendChild(canvas);
            canvas.width = window.innerWidth * dpr; canvas.height = window.innerHeight * dpr;
            canvas.style.width = "100%"; canvas.style.height = "100%"; return canvas;
          }
          function createShader(gl, type, source) { const s = gl.createShader(type); gl.shaderSource(s, source); gl.compileShader(s); return s; }
          function createProgram(gl, vsSource, fsSource) {
            const vs = createShader(gl, gl.VERTEX_SHADER, vsSource), fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
            const p = gl.createProgram(); gl.attachShader(p, vs); gl.attachShader(p, fs); gl.linkProgram(p); return p;
          }

          const programs = layers.map(({ id, frag }) => {
            const canvas = createCanvas(id);
            const gl = canvas.getContext("webgl", { preserveDrawingBuffer: true });
            const vsSource = `attribute vec4 a_position; void main(){ gl_Position = a_position; }`;
            const fsSource = frag();
            const program = createProgram(gl, vsSource, fsSource);
            const buffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
            const aPosition = gl.getAttribLocation(program, "a_position");
            gl.enableVertexAttribArray(aPosition); gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);
            const uTime = gl.getUniformLocation(program, "u_time");
            return { gl, program, canvas, uTime };
          });

          function resize() { programs.forEach(({ gl, canvas }) => { canvas.width = window.innerWidth * dpr; canvas.height = window.innerHeight * dpr; gl.viewport(0, 0, canvas.width, canvas.height); }); }
          window.addEventListener("resize", resize); resize();

          let time = 0, last = 0; const fps = 24, step = 1000 / fps;
          function render(ts) {
            if (ts - last >= step) {
              time += 0.015; programs.forEach(({ gl, program, uTime }) => { gl.useProgram(program); gl.uniform1f(uTime, time); gl.drawArrays(gl.TRIANGLES, 0, 6); });
              last = ts;
            }
            requestAnimationFrame(render);
          }
          requestAnimationFrame(render);
        }

        function initCanvas2DGrain() {
          const canvas = document.createElement("canvas"); canvas.className = "grain-canvas"; overlay.appendChild(canvas);
          const ctx = canvas.getContext("2d");
          function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
          function generateAlphaGrain() {
            const w = canvas.width, h = canvas.height, imageData = ctx.createImageData(w, h), data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
              const isGrain = Math.random() < 0.06, alpha = isGrain ? 20 + Math.random() * 20 : 0, gray = 180 + Math.random() * 30;
              data[i] = gray; data[i + 1] = gray; data[i + 2] = gray; data[i + 3] = alpha;
            }
            ctx.putImageData(imageData, 0, 0);
          }
          resizeCanvas(); window.addEventListener("resize", resizeCanvas); setInterval(generateAlphaGrain, 1000 / 24);
        }

        function baseFrag() {
          return `
          precision mediump float; uniform float u_time;
          float random(vec2 st){ return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453); }
          void main(){ vec2 uv=gl_FragCoord.xy*1.5; float g=random(uv+u_time*10.0); float gray=0.6+g*0.3; gl_FragColor=vec4(vec3(gray), g*0.04); }`;
        }
        function floatFrag() {
          return `
          precision mediump float; uniform float u_time;
          void main(){ vec2 uv=gl_FragCoord.xy*0.002+u_time*0.02; float flow=fract(sin(dot(uv, vec2(15.1,63.8))) * 10000.0); flow=smoothstep(0.4,1.0,flow); gl_FragColor=vec4(vec3(flow), flow*0.02); }`;
        }
        function warpFrag() {
          return `
          precision mediump float; uniform float u_time;
          void main(){ vec2 uv=gl_FragCoord.xy; float shift=sin(uv.y*0.05+u_time*2.0)*0.003; float g=fract(sin(dot((uv+vec2(shift,0.0))*1.2, vec2(12.9898,78.233)))*43758.5453); vec3 gray=vec3(g); gl_FragColor=vec4(gray, g*0.03); }`;
        }
      })();
    </script>
  </section>



  <div class="page">

    <h1>Button of Dictator</h1>

    <form id="username-form">
      <input type="text" id="username" placeholder="Enter your name" required>
      <button type="submit" class="small-btn">Submit Name</button>
    </form>

    <div class="actions">
      <button id="terminate-btn">Terminate</button>
    </div>

<div class="card">
  <div class="term">
    <div class="term-status">
      <span class="term-clock" id="term-clock">--:--:--</span>
      <span class="term-pos" id="term-pos">x: -  y: -</span>
    </div>
    <div class="term-body" id="term-body" aria-live="polite"></div>
  </div>
</div>

  </div>

<script>
  window.addEventListener('DOMContentLoaded', () => {
    // ====== 1) DOM ======
    const usernameForm  = document.getElementById('username-form');
    const usernameInput = document.getElementById('username');
    const terminateBtn  = document.getElementById('terminate-btn');

    // ====== 2) Supabase client（确保 <head> 已引入 @supabase/supabase-js@2）======
    const SUPABASE_URL = 'https://qvslxmokvbjhslbxdhtb.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InF2c2x4bW9rdmJqaHNsYnhkaHRiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDU2ODM1MzYsImV4cCI6MjA2MTI1OTUzNn0.fJ9jTo9yrKWZQ-Hif2-YJo5jWF1RolIsIeZSVB5TPxA';
    const supabase = (window.supabase && window.supabase.createClient)
      ? window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY)
      : null;

    // ====== 3) 小工具 ======
    const tprintln = (msg) => (window.term && term.println) ? term.println(msg) : Promise.resolve();

    function getSubdomain(host = location.hostname) {
      if (host === 'localhost' || /^\d{1,3}(\.\d{1,3}){3}$/.test(host)) return host;
      const parts = host.split('.');
      if (parts.length <= 2) return parts[0];
      return parts.slice(0, parts.length - 2).join('.');
    }

    function setAssignUI(lock) {
      usernameInput.disabled = !!lock;
      const submitBtn = usernameForm.querySelector('button[type="submit"]');
      if (submitBtn) submitBtn.disabled = !!lock;
    }

    // ====== 4) 首屏：访问日志 ======
    fetch('/api/update-log', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ action: 'access' })
    }).catch(console.error);

    // ====== 5) 初始化：根据 Supabase 的 assignedTo 锁 UI ======
    async function initAssignLockFromSupabase() {
      // 若没加载 supabase-js，直接放开
      if (!supabase) { setAssignUI(false); return; }

      const sub = getSubdomain();
      try {
        // 如果表里可能不存在该 subdomain 的行，推荐用 maybeSingle()
        const { data, error } = await supabase
          .from('logs')
          .select('assignedTo')
          .eq('subdomain', sub)
          .maybeSingle();

        if (error) {
          console.warn('Supabase check error:', error.message);
          setAssignUI(false); // 查询失败不拦截
          return;
        }

        if (data && data.assignedTo) {
          setAssignUI(true);
          await tprintln(`Subdomain ${sub} already assigned to: ${data.assignedTo}`);
        } else {
          setAssignUI(false);
        }
      } catch (e) {
        console.warn('Supabase check error:', e);
        setAssignUI(false);
      }
    }

    // 先拿到元素再调用（避免未定义）
    initAssignLockFromSupabase();

    // ====== 6) 提交用户名（含终端回显 & 防重复）======
    let isSubmitting = false;

    usernameForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      const username = usernameInput.value.trim();
      if (!username) {
        alert('Please enter your name.');
        await tprintln('warn: empty operator name');
        return;
      }
      if (isSubmitting) {
        await tprintln('warn: duplicate submission blocked');
        return;
      }
      isSubmitting = true;
      setAssignUI(true);

      try {
        const res = await fetch('/api/update-log', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ username, action: 'assign' })
        });
        const data = await res.json();
        if (!res.ok) throw new Error(data.message || 'Failed to record name');

        console.log('Name assigned:', data);

        await tprintln('Name recorded');
        await tprintln(`Subdomain ${getSubdomain()} assigned to: ${username}`);

        // ✅ 提交成功后就锁死（直到你清空 assignedTo 或换子域）
        setAssignUI(true);

        // 如果你希望把 assignedTo 也同步到 supabase（若 /api/update-log 没写入）
        // await supabase.from('logs').update({ assignedTo: username }).eq('subdomain', getSubdomain());

        alert('Name recorded successfully.');
      } catch (err) {
        console.error(err);
        await tprintln(`error: ${err.message || 'network error'}`);
        // 失败 -> 放开重试
        setAssignUI(false);
        alert('Something went wrong: ' + (err.message || 'network error'));
      } finally {
        isSubmitting = false;
      }
    });

    // ====== 7) 终结按钮 ======
    terminateBtn.addEventListener('click', async () => {
      const username = usernameInput.value.trim();
      if (!username) return alert('Please submit your name first.');
      if (!confirm('Are you sure you want to TERMINATE? This action cannot be undone.')) return;

      try {
        await tprintln('Operation Confirmed, executing...');

        // 1) terminate
        const terminateRes = await fetch('/api/update-log', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ username, action: 'terminate' })
        });
        const terminateData = await terminateRes.json();
        if (!terminateRes.ok) throw new Error(terminateData.message || 'Failed to record termination');

        // 2) 等 2 秒
        await new Promise(r => setTimeout(r, 2000));

        // 3) 轮询确认
        let confirmed = false;
        for (let i = 0; i < 10; i++) {
          const checkRes = await fetch('/api/check-log-status', { cache: 'no-store' });
          const checkData = await checkRes.json();
          if (checkRes.ok && checkData.status === 'terminated') { confirmed = true; break; }
          await new Promise(r => setTimeout(r, 1000));
        }
        if (!confirmed) throw new Error('Failed to confirm termination status.');

        // 4) remove subdomain
        const removeRes = await fetch('/api/remove-subdomain', { method: 'POST' });
        const removeData = await removeRes.json();
        if (!removeRes.ok) throw new Error(removeData.message || 'Failed to remove subdomain');

        await tprintln('Detached.');

        // （可选）如果你想让这个 subdomain 再次允许 assign，可清空 assignedTo
        // if (supabase) {
        //   await supabase.from('logs').update({ assignedTo: null }).eq('subdomain', getSubdomain());
        // }

        alert('Termination complete. Subdomain removed.');
        setTimeout(() => window.location.reload(), 10000);
      } catch (error) {
        console.error('Termination process failed:', error);
        await tprintln(`error: ${error.message}`);
        alert('Something went wrong: ' + error.message);
      }
    });
  });
</script>

</body>

</html>
