<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Terminal Log</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Project stylesheet for this page -->
  <link rel="stylesheet" href="css/log.css" />

  <!-- Fonts aligned with the 404 background -->
  <link rel="stylesheet"
    href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@100;200;300;400;500;600;700&family=Orbitron:wght@400;500;600;700;800;900&family=Saira:wght@100;200;300;400;500;600;700;800;900&display=swap" />

<link rel="icon" href="/images/favicon-terminate-flat.ico" sizes="any">
<link rel="icon" type="image/png" sizes="32x32" href="/images/terminate-flat-32.png">
<link rel="icon" type="image/png" sizes="64x64" href="/images/terminate-flat-64.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/terminate-flat-180.png">
</head>

<body>
<section class="section-background">
    <div class="scrolling-wrapper">
      <div class="dark-frame">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" preserveAspectRatio="none"
             style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: #4d4d4d; pointer-events: none; z-index: 0;">
          <defs>
            <filter id="softEdge" x="-10%" y="-10%" width="120%" height="120%">
              <feGaussianBlur in="SourceGraphic" stdDeviation="3"></feGaussianBlur>
            </filter>
          </defs>
          <path d="
            M2,10
            C2,3 3,2 10,2
            L90,2
            C97,2 98,3 98,10
            L98,90
            C98,97 97,98 90,98
            L10,98
            C3,98 2,97 2,90
            Z" fill="#999999" filter="url(#softEdge)"></path>
        </svg>
      </div>

      <div class="scrolling-track">
        <!-- Repeated 404 text shells -->
        <div class="bg-text-shell">
          <div class="bg-clone-shell">
            <div class="bg-text-clone r">TERMINATED</div>
            <div class="bg-text-clone g">TERMINATED</div>
            <div class="bg-text-clone b">TERMINATED</div>
          </div>
          <div data-text="TERMINATED" class="bg-text">TERMINATED</div>
        </div>
        <div class="bg-text-shell">
          <div class="bg-clone-shell">
            <div class="bg-text-clone r">TERMINATED</div>
            <div class="bg-text-clone g">TERMINATED</div>
            <div class="bg-text-clone b">TERMINATED</div>
          </div>
          <div class="bg-text">TERMINATED</div>
        </div>
        <div class="bg-text-shell">
          <div class="bg-clone-shell">
            <div class="bg-text-clone r">TERMINATED</div>
            <div class="bg-text-clone g">TERMINATED</div>
            <div class="bg-text-clone b">TERMINATED</div>
          </div>
          <div class="bg-text">TERMINATED</div>
        </div>
        <div class="bg-text-shell">
          <div class="bg-clone-shell">
            <div class="bg-text-clone r">TERMINATED</div>
            <div class="bg-text-clone g">TERMINATED</div>
            <div class="bg-text-clone b">TERMINATED</div>
          </div>
          <div class="bg-text">TERMINATED</div>
        </div>
        <div class="bg-text-shell">
          <div class="bg-clone-shell">
            <div class="bg-text-clone r">TERMINATED</div>
            <div class="bg-text-clone g">TERMINATED</div>
            <div class="bg-text-clone b">TERMINATED</div>
          </div>
          <div class="bg-text">TERMINATED</div>
        </div>
        <div class="bg-text-shell">
          <div class="bg-clone-shell">
            <div class="bg-text-clone r">TERMINATED</div>
            <div class="bg-text-clone g">TERMINATED</div>
            <div class="bg-text-clone b">TERMINATED</div>
          </div>
          <div class="bg-text">TERMINATED</div>
        </div>
        <div class="bg-text-shell">
          <div class="bg-clone-shell">
            <div class="bg-text-clone r">TERMINATED</div>
            <div class="bg-text-clone g">TERMINATED</div>
            <div class="bg-text-clone b">TERMINATED</div>
          </div>
          <div class="bg-text">TERMINATED</div>
        </div>

<script>
(function () {
  const track  = document.querySelector('.scrolling-track');
  if (!track) return;

  const shells = Array.from(track.querySelectorAll('.bg-text-shell'));
  const items  = Array.from(track.querySelectorAll('.bg-text'));

  // 动画参数
  const speed = 0.5;                 // px/帧（你原先的速度）
  let step   = 0;                    // 一次完整循环应位移的距离
  let pos    = 0;                    // 当前 translateX 偏移（正值向左）
  let rafId  = null;

  // 用户减少动画偏好
  const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

  // 等字体就绪，再测量（fallback 安全）
  async function waitForFonts() {
    if (document.fonts && document.fonts.ready) {
      try { await document.fonts.ready; } catch (e) {}
    }
    // 再等两帧，确保回流完成
    await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
  }

  // 计算循环步长：用相邻两个 shell 的 offsetLeft 之差
  function computeStep() {
    if (shells.length >= 2) {
      const a = shells[0].offsetLeft;
      const b = shells[1].offsetLeft;
      const d = b - a;
      if (d > 0) return d;
    }
    // 兜底：文字宽度 + 10vw（与旧逻辑一致）
    const itemWidth = items[0]?.offsetWidth || 0;
    const gap = window.innerWidth * 0.1;
    return itemWidth + gap;
  }

  function applyTransform() {
    // 用模运算平滑回环；注意是负方向平移
    const wrapped = ((pos % step) + step) % step;
    track.style.transform = `translateX(${-wrapped}px)`;
  }

  function tick() {
    pos += speed;
    applyTransform();
    rafId = requestAnimationFrame(tick);
  }

  // 重新测量（窗口变化/字体变化时）
  function remeasure() {
    const oldStep = step;
    step = computeStep();
    if (step <= 0) return;

    // 将当前位置按新步长重新包裹，避免跳变
    pos = ((pos % step) + step) % step;
    applyTransform();
  }

  // 初始化
  (async function init() {
    // 初始透明度淡入（保持你原来的效果）
    items.forEach(el => { el.style.opacity = '0'; el.style.transition = 'opacity 1s ease-out'; });

    await waitForFonts();
    step = computeStep();
    applyTransform();

    // 1s 后开始动画（沿用你的时序）
    setTimeout(() => {
      if (!prefersReduced) rafId = requestAnimationFrame(tick);
      items.forEach(el => { el.style.opacity = '1'; });
    }, 1000);

    // 监听 resize（含 DPR 变化）
    let resizeTimer = null;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(remeasure, 50);
    });

    // 字体集合事件（部分浏览器支持）
    if (document.fonts && typeof document.fonts.addEventListener === 'function') {
      document.fonts.addEventListener('loadingdone', remeasure);
      document.fonts.addEventListener('loadingerror', remeasure);
    }
  })();
})();
</script>


        <style>
          .bg-text, .bg-text-clone { pointer-events: none; will-change: transform, opacity; }
          .bg-text-clone { opacity: 0; transition: transform 0.05s ease, opacity 0.1s ease; mix-blend-mode: screen; z-index: 0; }
        </style>

        <script>
          document.addEventListener("DOMContentLoaded", () => {
            const shells = document.querySelectorAll('.bg-text-shell');
            let isCrtRunning = false;
            let tinyGlitchTimer = null;
            let bigGlitchTimer = null;

            function clearClones() {
              shells.forEach(shell => {
                shell.querySelectorAll('.bg-text-clone').forEach(clone => {
                  clone.style.opacity = 0;
                  clone.style.transform = 'translate(0, 0) scale(1)';
                  clone.style.filter = 'none';
                });
              });
            }
            function doTinyGlitch() {
              if (isCrtRunning) return;
              shells.forEach(shell => {
                const clones = shell.querySelectorAll('.bg-text-clone');
                const offsetX = () => (Math.random() * 12 - 6) + "px";
                const offsetY = () => (Math.random() * 12 - 6) + "px";
                const randomOpacity = 0.15 + Math.random() * 0.1;
                clones.forEach(clone => {
                  clone.style.opacity = randomOpacity.toFixed(2);
                  clone.style.transform = `translate(${offsetX()}, ${offsetY()})`;
                  clone.style.filter = "none";
                });
                setTimeout(() => {
                  clones.forEach(clone => {
                    clone.style.opacity = 0;
                    clone.style.transform = `translate(0, 0)`;
                  });
                }, 200);
              });
            }
            function scheduleTinyGlitch() {
              if (tinyGlitchTimer) clearTimeout(tinyGlitchTimer);
              if (isCrtRunning) return;
              doTinyGlitch();
              tinyGlitchTimer = setTimeout(scheduleTinyGlitch, Math.random() * 1000 + 1000);
            }
            function doBigGlitchOnce() {
              shells.forEach(shell => {
                const clones = shell.querySelectorAll('.bg-text-clone');
                const offsetX = () => (Math.random() * 100 - 50) + "px";
                const offsetY = () => (Math.random() * 100 - 50) + "px";
                const randomOpacity = 0.7 + Math.random() * 0.25;
                clones.forEach(clone => {
                  clone.style.opacity = randomOpacity.toFixed(2);
                  clone.style.transform = `translate(${offsetX()}, ${offsetY()}) scale(${1 + Math.random() * 0.08})`;
                  clone.style.filter = "blur(0.6px) contrast(150%)";
                });
                setTimeout(() => {
                  clones.forEach(clone => {
                    clone.style.opacity = 0;
                    clone.style.transform = `translate(0, 0) scale(1)`;
                    clone.style.filter = "none";
                  });
                }, 180);
              });
            }
            function scheduleBigGlitch() {
              if (bigGlitchTimer) clearTimeout(bigGlitchTimer);
              if (isCrtRunning) return;
              const blastCount = Math.floor(Math.random() * 3) + 1;
              let delay = 0;
              for (let i = 0; i < blastCount; i++) {
                setTimeout(() => { if (!isCrtRunning) doBigGlitchOnce(); }, delay);
                delay += 160 + Math.random() * 40;
              }
              const nextDelay = delay + Math.random() * 3000 + 3000;
              bigGlitchTimer = setTimeout(scheduleBigGlitch, nextDelay);
            }
            function startGlitches() { scheduleTinyGlitch(); scheduleBigGlitch(); }
            function stopGlitches() {
              clearTimeout(tinyGlitchTimer); clearTimeout(bigGlitchTimer);
              tinyGlitchTimer = null; bigGlitchTimer = null; clearClones();
            }
            function crtEffect() {
              isCrtRunning = true; stopGlitches();
              shells.forEach(shell => {
                const texts = shell.querySelectorAll('.bg-text, .bg-text-clone');
                texts.forEach(text => {
                  text.style.transition = "none";
                  text.style.transform = "scaleY(1) scaleX(1) translate(0, 0)";
                  text.style.opacity = "1"; text.style.filter = "none";
                });
                setTimeout(() => {
                  texts.forEach(text => {
                    if (text.classList.contains('bg-text-clone')) {
                      text.style.transition = "opacity 0.2s ease-out, transform 0.2s ease-in";
                      text.style.opacity = "0"; text.style.transform = "scaleY(0.05) scaleX(1)";
                    } else {
                      text.style.transition = "transform 0.2s ease-in";
                      text.style.transform = "scaleY(0.05) scaleX(1)"; text.style.opacity = "1";
                    }
                  });
                }, 10);
                setTimeout(() => {
                  texts.forEach(text => {
                    text.style.transition = "transform 0.1s ease-in, opacity 0.1s ease-out";
                    text.style.transform = "scaleY(0.05) scaleX(0)"; text.style.opacity = "0";
                  });
                }, 210);
                setTimeout(() => {
                  texts.forEach(text => {
                    text.style.transition = "opacity 3s ease-out, transform 0s";
                    text.style.transform = "scaleY(1) scaleX(1)"; text.style.opacity = "1";
                  });
                  isCrtRunning = false; startGlitches();
                }, 1800);
              });
            }
            setTimeout(() => { crtEffect(); setInterval(crtEffect, 12000); }, 3000);
          });
        </script>
      </div>
    </div>

    <div class="glass-layer"></div>

    <div class="grain-overlay"></div>

    <script>
      (function(){
        const overlay = document.querySelector(".grain-overlay");
        if (!overlay) return;
        const style = document.createElement('style');
        style.textContent = `
          .grain-overlay { pointer-events: none; opacity: 0.15; }
          .grain-overlay canvas {
            width: 100%; height: 100%; display: block; position: absolute; top: 0; left: 0;
            image-rendering: pixelated;
          }`;
        document.head.appendChild(style);

        if (supportsWebGL()) { initWebGLGrain(); } else { initCanvas2DGrain(); }

        function supportsWebGL() { try { const c = document.createElement("canvas"); return !!window.WebGLRenderingContext && c.getContext("webgl"); } catch(e){ return false; } }

        function initWebGLGrain() {
          const layers = [
            { id: "grain-base",  frag: baseFrag },
            { id: "grain-float", frag: floatFrag },
            { id: "grain-warp",  frag: warpFrag }
          ];
          const dpr = window.devicePixelRatio || 1;

          function createCanvas(id) {
            const canvas = document.createElement("canvas");
            canvas.id = id; canvas.className = "grain-canvas"; overlay.appendChild(canvas);
            canvas.width  = window.innerWidth * dpr; canvas.height = window.innerHeight * dpr;
            canvas.style.width = "100%"; canvas.style.height = "100%"; return canvas;
          }
          function createShader(gl, type, source){ const s=gl.createShader(type); gl.shaderSource(s, source); gl.compileShader(s); return s; }
          function createProgram(gl, vsSource, fsSource){
            const vs=createShader(gl, gl.VERTEX_SHADER, vsSource), fs=createShader(gl, gl.FRAGMENT_SHADER, fsSource);
            const p=gl.createProgram(); gl.attachShader(p, vs); gl.attachShader(p, fs); gl.linkProgram(p); return p;
          }

          const programs = layers.map(({ id, frag }) => {
            const canvas = createCanvas(id);
            const gl = canvas.getContext("webgl", { preserveDrawingBuffer: true });
            const vsSource = `attribute vec4 a_position; void main(){ gl_Position = a_position; }`;
            const fsSource = frag();
            const program = createProgram(gl, vsSource, fsSource);
            const buffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([ -1,-1, 1,-1, -1,1,  -1,1, 1,-1, 1,1 ]), gl.STATIC_DRAW);
            const aPosition = gl.getAttribLocation(program, "a_position");
            gl.enableVertexAttribArray(aPosition); gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);
            const uTime = gl.getUniformLocation(program, "u_time");
            return { gl, program, canvas, uTime };
          });

          function resize(){ programs.forEach(({ gl, canvas }) => { canvas.width=window.innerWidth*dpr; canvas.height=window.innerHeight*dpr; gl.viewport(0,0,canvas.width,canvas.height); }); }
          window.addEventListener("resize", resize); resize();

          let time=0,last=0; const fps=24, step=1000/fps;
          function render(ts){
            if(ts-last>=step){
              time+=0.015; programs.forEach(({gl,program,uTime})=>{ gl.useProgram(program); gl.uniform1f(uTime,time); gl.drawArrays(gl.TRIANGLES,0,6); });
              last=ts;
            }
            requestAnimationFrame(render);
          }
          requestAnimationFrame(render);
        }

        function initCanvas2DGrain(){
          const canvas=document.createElement("canvas"); canvas.className="grain-canvas"; overlay.appendChild(canvas);
          const ctx=canvas.getContext("2d");
          function resizeCanvas(){ canvas.width=window.innerWidth; canvas.height=window.innerHeight; }
          function generateAlphaGrain(){
            const w=canvas.width,h=canvas.height, imageData=ctx.createImageData(w,h), data=imageData.data;
            for(let i=0;i<data.length;i+=4){
              const isGrain=Math.random()<0.06, alpha=isGrain?20+Math.random()*20:0, gray=180+Math.random()*30;
              data[i]=gray; data[i+1]=gray; data[i+2]=gray; data[i+3]=alpha;
            }
            ctx.putImageData(imageData,0,0);
          }
          resizeCanvas(); window.addEventListener("resize", resizeCanvas); setInterval(generateAlphaGrain, 1000/24);
        }

        function baseFrag(){ return `
          precision mediump float; uniform float u_time;
          float random(vec2 st){ return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453); }
          void main(){ vec2 uv=gl_FragCoord.xy*1.5; float g=random(uv+u_time*10.0); float gray=0.6+g*0.3; gl_FragColor=vec4(vec3(gray), g*0.04); }`; }
        function floatFrag(){ return `
          precision mediump float; uniform float u_time;
          void main(){ vec2 uv=gl_FragCoord.xy*0.002+u_time*0.02; float flow=fract(sin(dot(uv, vec2(15.1,63.8))) * 10000.0); flow=smoothstep(0.4,1.0,flow); gl_FragColor=vec4(vec3(flow), flow*0.02); }`; }
        function warpFrag(){ return `
          precision mediump float; uniform float u_time;
          void main(){ vec2 uv=gl_FragCoord.xy; float shift=sin(uv.y*0.05+u_time*2.0)*0.003; float g=fract(sin(dot((uv+vec2(shift,0.0))*1.2, vec2(12.9898,78.233)))*43758.5453); vec3 gray=vec3(g); gl_FragColor=vec4(gray, g*0.03); }`; }
      })();
    </script>
  </section>

  <!-- Foreground content -->
  <div class="page">
    <header>
      <h1>Terminal Log</h1>
      <p class="hint">Domains, actions, and timestamps from your shutdown pipeline.</p>
      <div class="toolbar">
        <button class="btn" id="resetBtn" style="display:none">Reset logs</button>
      </div>
    </header>

    <div id="loading" class="state">Loading logs…</div>
    <div class="grid" id="log-grid" role="list"></div>
    <div class="footer">This page dynamically lists terminal interaction logs. Read the full project introduction on 
    <a href="https://github.com/omnifrog-art/button-of-dictator"
       id="github-link"
       class="link"
       target="_blank"
       rel="noopener">
       GitHub →
    </a></div>
  </div>

  <!-- Supabase & your log loader -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js"></script>
  <script src="log.js" defer></script>

  <!-- Hover → background word binding (no change to your log.js required) -->
  <script>
    (function () {
      const grid = document.getElementById('log-grid');

      function deriveHeadFromCard(card) {
        const ds = card.getAttribute('data-subdomain');
        if (ds && ds.trim()) return ds.trim();
        const domEl = card.querySelector('.domain');
        if (!domEl) return 'LOG';
        const raw = domEl.textContent || '';
        // Normalize spaces & separators then split by dots
        let text = raw.replace(/\s+/g, '').replace(/·/g, '');
        const parts = text.split('.').filter(Boolean);
        if (parts.length >= 2) return parts[0];
        const hy = text.split('-')[0];
        return hy || text || 'LOG';
      }

      let last = 'LOG';
      function setWord(w) {
        const up = (w || 'LOG').toUpperCase();
        if (up === last) return;
        last = up;
        if (window.__bgMarquee && typeof window.__bgMarquee.set === 'function') {
          window.__bgMarquee.set(up);
        }
      }

      grid.addEventListener('mouseover', (e) => {
        const card = e.target.closest('.card');
        if (!card) return;
        setWord(deriveHeadFromCard(card));
      });
      grid.addEventListener('mouseleave', () => setWord('LOG'));

      // Optional: if your log.js wants to hint the marquee after rendering a batch
      window.__bgMarqueeBind = function () { };
    })();
  </script>

  <!-- Reset util (kept from your previous page design) -->
  <script>
    async function resetLogs() {
      try {
        const res = await fetch('/api/reset-logs', { method: 'POST' });
        const data = await res.json();
        if (!res.ok) throw new Error(data.error || data.message || 'Reset failed');
        location.reload();
      } catch (err) {
        alert('Reset error: ' + err.message);
      }
    }
    if (location.hostname === 'localhost' || location.search.includes('reset=1')) {
      const btn = document.getElementById('resetBtn');
      btn.style.display = '';
      btn.addEventListener('click', resetLogs);
    }
  </script>

  <script>
  // 悬停卡片 -> 背景字幕换词（会 1s ease-in cross-fade）
  (function(){
    const grid = document.getElementById('log-grid');
    if (!grid) return;

    function deriveHeadFromCard(card){
      const ds = card.getAttribute('data-subdomain');
      if (ds && ds.trim()) return ds.trim();
      const domEl = card.querySelector('.domain');
      if (!domEl) return 'LOG';
      const raw = domEl.textContent || '';
      let text = raw.replace(/\s+/g,'').replace(/·/g,'');
      const parts = text.split('.').filter(Boolean);
      if (parts.length >= 2) return parts[0];
      return text.split('-')[0] || text || 'LOG';
    }

    grid.addEventListener('mouseover', (e) => {
      const card = e.target.closest('.card');
      if (!card) return;
      const head = deriveHeadFromCard(card).toUpperCase();
      if (window.__bgMarquee) window.__bgMarquee.set(head);
    });

    grid.addEventListener('mouseleave', () => {
      if (window.__bgMarquee) window.__bgMarquee.set('LOG');
    });
  })();
</script>

</body>

</html>
